import { Secret } from 'jsonwebtoken';
import { UserFromToken, JWTServerToken, JWTUserToken } from './signing';
import { isFunction } from './utils';
import { TokenOrProvider, UnknownType, UserResponse } from './types';

/**
 * TokenManager
 *
 * Handles all the operations around userEntity token.
 */
export class TokenManager<UserType extends UnknownType = UnknownType> {
  loadTokenPromise: Promise<string> | null;
  type: 'static' | 'provider';
  secret?: Secret;
  token?: string;
  tokenProvider?: TokenOrProvider;
  userEntity?: UserResponse<UserType>;
  /**
   * Constructor
   *
   * @param {Secret} secret
   */
  constructor(secret?: Secret) {
    this.loadTokenPromise = null;
    if (secret) {
      this.secret = secret;
    }

    this.type = 'static';

    if (this.secret) {
      this.token = JWTServerToken(this.secret);
    }
  }

  /**
   * Set the static string token or token provider.
   * Token provider should return a token string or a promise which resolves to string token.
   *
   * @param {TokenOrProvider} tokenOrProvider
   * @param {UserResponse<UserType>} userEntity
   */
  setTokenOrProvider = async (
    tokenOrProvider: TokenOrProvider,
    userEntity: UserResponse<UserType>,
  ) => {
    this.validateToken(tokenOrProvider, userEntity);
    this.userEntity = userEntity;

    if (isFunction(tokenOrProvider)) {
      this.tokenProvider = tokenOrProvider;
      this.type = 'provider';
    }

    if (typeof tokenOrProvider === 'string') {
      this.token = tokenOrProvider;
      this.type = 'static';
    }

    if (!tokenOrProvider && this.userEntity && this.secret) {
      this.token = JWTUserToken(this.secret, userEntity.id, {}, {});
      this.type = 'static';
    }

    await this.loadToken();
  };

  /**
   * Resets the token manager.
   * Useful for client disconnection or switching userEntity.
   */
  reset = () => {
    this.token = undefined;
    this.userEntity = undefined;
    this.loadTokenPromise = null;
  };

  // Validates the userEntity token.
  validateToken = (tokenOrProvider: TokenOrProvider, userEntity: UserResponse<UserType>) => {
    // allow empty token for anon userEntity
    if (userEntity && userEntity.anon && !tokenOrProvider) return;

    // Don't allow empty token for non-server side client.
    if (!this.secret && !tokenOrProvider) {
      throw new Error('User token can not be empty');
    }

    if (
      tokenOrProvider &&
      typeof tokenOrProvider !== 'string' &&
      !isFunction(tokenOrProvider)
    ) {
      throw new Error('userEntity token should either be a string or a function');
    }

    if (typeof tokenOrProvider === 'string') {
      // Allow empty token for anonymous users
      if (userEntity.anon && tokenOrProvider === '') return;

      const tokenUserId = UserFromToken(tokenOrProvider);
      if (
        tokenOrProvider != null &&
        (tokenUserId == null || tokenUserId === '' || tokenUserId !== userEntity.id)
      ) {
        throw new Error(
          'userToken does not have a user_id or is not matching with userEntity.id',
        );
      }
    }
  };

  // Resolves when token is ready. This function is simply to check if loadToken is in progress, in which
  // case a function should wait.
  tokenReady = () => this.loadTokenPromise;

  // Fetches a token from tokenProvider function and sets in tokenManager.
  // In case of static token, it will simply resolve to static token.
  loadToken = () => {
    // eslint-disable-next-line no-async-promise-executor
    this.loadTokenPromise = new Promise(async (resolve) => {
      if (this.type === 'static') {
        return resolve(this.token);
      }

      if (this.tokenProvider && typeof this.tokenProvider !== 'string') {
        this.token = await this.tokenProvider();
        resolve(this.token);
      }
    });

    return this.loadTokenPromise;
  };

  // Returns a current token
  getToken = () => {
    if (this.token) {
      return this.token;
    }

    if (this.userEntity && this.userEntity.anon && !this.token) {
      return this.token;
    }

    if (this.secret) {
      return JWTServerToken(this.secret);
    }

    throw new Error(
      `Both secret and userEntity tokens are not set. Either client.setUser wasn't called or client.disconnect was called`,
    );
  };

  isStatic = () => this.type === 'static';
}
